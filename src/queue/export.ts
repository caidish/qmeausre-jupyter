/**
 * Export queue entries to MeasureIt Python code
 */

import { QueueEntry, DatabaseConfig } from "../types/queue";

/**
 * Generate DatabaseEntry Python code
 * @param db - Database configuration
 * @returns Python code string for DatabaseEntry
 *
 * MeasureIt's DatabaseEntry signature: DatabaseEntry(db_path, exp_name, sample_name)
 */
function generateDatabaseEntry(db: DatabaseConfig): string {
  // Use MeasureIt's get_path to construct database path
  const dbPath = `str(get_path("databases") / "${db.database}")`;

  return `DatabaseEntry(${dbPath}, "${db.experiment}", "${db.sample}")`;
}

/**
 * Generate Python variable name from sweep name
 * @param name - Human-readable name
 * @param index - Queue index for uniqueness
 * @returns Valid Python variable name
 */
function generateVarName(name: string, index: number): string {
  // Convert to valid Python identifier
  const sanitized = name
    .toLowerCase()
    .replace(/[^a-z0-9_]/g, "_")
    .replace(/^[0-9]/, "_$&");

  return `sweep_${index}_${sanitized}`;
}

/**
 * Export queue entries to executable Python code
 * @param entries - Queue entries to export
 * @returns Complete Python script
 */
export function exportSweepQueue(entries: QueueEntry[]): string {
  if (entries.length === 0) {
    return "# Empty queue - no sweeps to run\n";
  }

  const sections: string[] = [];

  // Determine which sweep types are used for imports
  const sweepTypes = new Set<string>();
  entries.forEach((entry) => {
    switch (entry.sweepType) {
      case "sweep0d":
        sweepTypes.add("Sweep0D");
        break;
      case "sweep1d":
        sweepTypes.add("Sweep1D");
        break;
      case "sweep2d":
        sweepTypes.add("Sweep2D");
        break;
      case "simulsweep":
        sweepTypes.add("SimulSweep");
        break;
      case "gateleakage":
        sweepTypes.add("GateLeakage");
        break;
    }
  });

  const needsDatabase = entries.some((e) => e.database);
  const sweepImports = Array.from(sweepTypes).sort().join(", ");

  // Header with full imports for runnable script
  sections.push(`# Generated Sweep Queue
# Generated by QMeasure Jupyter Extension
# Total sweeps: ${entries.length}

from measureit.tools.sweep_queue import SweepQueue${needsDatabase ? ", DatabaseEntry" : ""}
from measureit import ${sweepImports}${needsDatabase ? ", get_path" : ""}
from measureit.tools import ensure_qt
import qcodes as qc

# Initialize station
station = qc.Station.default

# Ensure Qt event loop is running
ensure_qt()

`);

  // Generate setup code for each sweep
  sections.push("# ===== Sweep Setup =====\n");

  entries.forEach((entry, index) => {
    const varName = generateVarName(entry.name, index);
    sections.push(`# ${index + 1}. ${entry.name} (${entry.sweepType})`);

    // Replace the sweep variable name with our generated one
    // Look for pattern like "s_1D = Sweep1D(...)" not "set_param = ..."
    let setupCode = entry.code.setup;

    // Find the line that creates the sweep object (e.g., s_1D = Sweep1D(...))
    const sweepVarMatch = setupCode.match(/^(\w+)\s*=\s*Sweep/m);
    if (sweepVarMatch && sweepVarMatch[1]) {
      const originalVar = sweepVarMatch[1];
      // Replace all occurrences of the original sweep variable with our generated one
      setupCode = setupCode.replace(
        new RegExp(`\\b${originalVar}\\b`, "g"),
        varName,
      );
    }

    sections.push(setupCode);
    sections.push("");
  });

  // Build the queue
  sections.push("# ===== Build Queue =====\n");
  sections.push("sq = SweepQueue()\n");

  entries.forEach((entry, index) => {
    const varName = generateVarName(entry.name, index);

    if (entry.database) {
      // Add with database entry
      const dbEntry = generateDatabaseEntry(entry.database);
      sections.push(`# Add sweep ${index + 1}: ${entry.name}`);
      sections.push(`sq += (${dbEntry}, ${varName})`);
    } else {
      // Add without database entry
      sections.push(`# Add sweep ${index + 1}: ${entry.name}`);
      sections.push(`sq += ${varName}`);
    }
    sections.push("");
  });

  // Start the queue
  sections.push("# ===== Run Queue =====\n");
  sections.push('print(f"Starting queue with {len(sq)} sweeps...")');
  sections.push("sq.start()");
  sections.push('print("Queue completed!")');

  return sections.join("\n");
}

/**
 * Export a single entry with optional database configuration
 * @param entry - Queue entry
 * @param includeStart - Whether to include the start code (default: true)
 * @returns Python code string
 */
export function exportSingleEntry(
  entry: QueueEntry,
  includeStart: boolean = true,
): string {
  const sections: string[] = [];

  // Header
  sections.push(`# ${entry.name} (${entry.sweepType})`);
  sections.push("");

  // Setup code
  sections.push(entry.code.setup);
  sections.push("");

  // Database entry if present
  if (entry.database && includeStart) {
    sections.push("# Database configuration");
    const dbEntry = generateDatabaseEntry(entry.database);
    sections.push(`db_entry = ${dbEntry}`);
    sections.push("");
  }

  // Start code if requested
  if (includeStart) {
    sections.push(entry.code.start);
  }

  return sections.join("\n");
}
